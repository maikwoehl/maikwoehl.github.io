---
title: PipelinedIterator - a design pattern
author: Maik
layout: post
categories: journal
tags: [software, design, pattern]
---

Whenever you have an iteration process in an embedded systems context, you want to save time through iteration and you have to do some things before and after the iteration. The first idea will be a looping state machine or a really big chunk of code that will sequentially execute before and after the iteration step occurs. Both ways have some downsides: On the one hand you can't afford to spend the time on stepping through a looping state machine and on the other hand you don't want to have big chunks of code. For that problem here is a solution: Embedding an iterator structure into an iterator-powered pipeline.

But first we discuss some related work to show that the concept is not new, but different to others.

## Related work
Zhu describes in his work [1] a pipeline software architecture for signal processing. It is the standard way of converting an analog signal to digital, process it and convert an response signal from digital to analog. He says that a parallel processing of information through a pipeline will be faster than a sequential state-dependent processing. That can be translated to software architecture and there the same effects appear. For a pipeline architecture substantially more memory than for a state-based architecture is needed, because you must store information between phases in memory and transport it through the pipeline.

The Rust crate iterpipes [2] allows to connect multiple iterators with different actions together. That is something like this pattern, because every stage or phase is pushed forward with every next()-call. By chaining the iterpipes together it is possible to get a similiar behaviour like this pattern describes.

## Concept
The *PipelinedIterator* allows to execute queued instructions on an element that changes on every iteration. A processing cycle consists of the four phases fetch, decode, execute and write. Whatever program is executing in the execution phase controls the iteration speed. 

The fetch phase is responsible for checking the limits of the list object and fetching the next element or signaling an upcoming halt.

The decode phase prepares the data structures used by the execution phase. It also generates control signals for the programs in execution phase. In this phase any other input signal can be processed and translated into a set of control and data signals for the execution phase. In other words the injection of additional informations and conditions into the iteration process is possible.

The execution phase consists of all data processing related tasks. All informations that are generated by a given element and input signals will be handed over to the write phase.

The write phase than generates the output signals of the outer object. 

Let's define some constraints to get a stable model:

 * Every phase must implement an asynchronous reset to switch to initial or default values in case of an iteration restart signal. 
 * It is a matter of implementation in the fetch phase whether the pipeline can traverse the objects forwards or backwards. A traversal from both sides in a switching manner is possible, if the execution phase don't expect a specific order of iteration.
 * Control and data signals inside the phases are read-only or write-only.
 * All phases must be aware of an outer halt signal as every outer event can lead to an execution or iteration halt.
 * In a case of a halt the write phase must be able to finish the write operation or must store the information beyond a possible reset to prevent data loss.
 * A halt signal should not flush the phases state memory. 
 * The execution phase should have the possibility to stall the pipeline as well. Any program could need more time for calculations so the pipeline must be able to wait if needed. The iteration then must be delayable.

As this definition enforces the control and data signals to be read or write only inside the phases, a buffer between the phases must be implemented. If the outer process is reading informations from the pipeline, they must be copied to prevent any effect on the pipeline process. 

It seems an interface for start and halt input signals, any input or output data and done and stall output signals should be sufficient. For further study a research implementation is presented below. In a production environment the programmer can be forced to include additional conditions (and heuristics) to meet system constraints (time, sensors, etc...)

# Concretization
The phase-buffer can programmatically written as a `struct`, one struct for the data paths between phases and one struct for the control paths between phases. The original structures are initialized by the phases and a copy is passed to the buffer. To prevent a data change on accident an immutable reference to the copy is passed to the next phase. The outer structure can access the buffer contents through immutable references or copies, if needed. 

Due to the use case for embedded software the execution phase may need more than one cycle, so a *pipeline stall* signal must be provided. A ready flag can be emitted to provide an information about the running calculations. Therefore the next iteration is only processed when the execution phase signals a ready state. 

A stop signal flushes the buffers except the last one. The write process must be completed to prevent loss of already calculated results. The write phase is defined as the official data exit because the data flow path inside the pipeline ends there. So the write phase needs a done flag.

# Proof-of-concept

To proof the portability of the design pattern a reference implementation in Rust will be implemented. For simulation of the necessary interfaces of the Testsystem we introduce a TestControl data structure:

```rust
pub struct TestControl {
    pub test_id: String,
    pub enable: bool,
    pub id_match: bool,
    pub output: Vec<String>,
}
```

Then we implement a rudimentary TestMachine that handles our requests:

```rust
pub struct TestMachine;

impl TestMachine {
    pub fn run(control: &mut TestControl) {
       let test_ids = vec![
           "ES_ASPLETM-272".to_string(),
           "ES_ASPLETM-273".to_string(),
           "ES_ASPLETM-274".to_string(),
       ];

       control.id_match = test_ids.contains(&control.test_id);

       if control.enable {
           // Do something
       }
    }
}
```

Now we design our data structure that flows inside the pipeline:

```rust
pub struct IterData<T> {
    data: T,
}

impl<T> IterData<T> {
    pub fn new(new_data: T) -> Self {
        Self { data: new_data }
    }
}

impl<T> Deref for IterData<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.data
    }
}
```

The data is generic over `T` because the concrete type is not known at this point. We implement the *Deref*-Trait for `IterData` to be able to access directly to the data inside. The data flow between phases is encapsulated inside a *Result* structure:

```rust
pub type PhaseResult<T> = Result<IterData<T>, bool>;
```

To ensure the constraints of the design pattern the following Trait is introduced:

```rust
pub trait Pipeline<I, O> {
    fn clk(&mut self);
    fn rst(&mut self);
    fn stall(&mut self, flag: bool);
    fn halt(&mut self, flag: bool);
    fn run(&mut self) -> PhaseResult<O>;
    fn pipe(&mut self, data: &PhaseResult<I>);
}
```

We ensure that input and output data are encapsulated inside a `PhaseResult` and the entry and exit points of data flow.

At last we need a control structure for every pipeline phase:

```rust
pub struct Control {
    pub clk: bool,
    pub rst: bool,
    pub stall: bool,
    pub halt: bool,
}

impl Control {
    pub fn is_ready(&self) -> bool {
        (self.clk == true) && (self.rst == false) && (self.stall == false) && (self.halt == false)
    }
}
```
Every phase needs a check mechanism for ready state. A macro implementation for this is possible. We look at that later.

The next subsections will describe the four phases: Fetch, Decode, Execute and Write.

## Fetch

The fetch phase holds an iterator and reads from the list of test identifier. When the list exhausted a `done` signal must be send.

```rust
pub struct Fetch {
    test_ids: Vec<String>,
    done: bool,
    index: usize,
    control: Control,
}

impl Fetch {
    pub fn new(ids: Vec<String>) -> Fetch {
        Fetch {
            test_ids: ids,
            done: false,
            index: 0,
            control: Control::default(),
        }
    }
    pub fn is_done(&self) -> bool {
        self.done
    }
}
```

That is followed by the pipeline definition:

```rust
impl Pipeline<(), String> for Fetch {
    fn pipe(&mut self, data: &PhaseResult<()>) {
        data.expect("to be nothing");
    }
    fn run(&mut self) -> PhaseResult<String> {
        if self.control.is_ready() == false {
            return Err(false);
        }
        self.control.clk = false;

        match self.test_ids.get(self.index) {
            Some(key) => {
                self.index = self.index + 1;
                Ok(IterData::new(key.clone()))
            }
            None => {
                self.done = true;
                Err(true)
            }
        }
    }
    fn clk(&mut self) {
        self.control.clk = true;
    }
    fn rst(&mut self) {
        self.control.rst = true;
        self.done = false;
        self.index = 0;
        self.control.rst = false;
    }
    fn stall(&mut self, flag: bool) {
        self.control.stall = flag;
    }
    fn halt(&mut self, flag: bool) {
        self.control.halt = flag;
    }
}
```

Note that the input type is `()` as this is the first phase. The output type is `String` because we send a test-id into the pipeline. On every clock-cycle we get the test-id on current index, if there is one, increment the index counter and send it into the pipeline. If there is no key left, the following request will be branch to `None` and return `Err(true)` signaling an intended fetching error. 

The signal functions can be implemented through a macro, because they don't change except the `rst`-signal, because a reset-procedure is different in every phase.

## Decode
The next phase is decoding all informations and generates a TestControl structure to pass into the execution phase. At first we implement the decode phase:

```rust
pub struct Decode {
    test_control: testsystem::TestControl,
    control: Control,
    test_id: String,
}

impl Decode {
    pub fn new() -> Self {
        Decode::default()
    }
    pub fn requests_reset(&self) -> bool {
        self.test_control.id_match
    }
}
```

The phase offers a `requests_reset()`-function to answer for the question after a required reset due to previous test match. At next we implement the pipeline for this phase:

```rust
impl Pipeline<String, testsystem::TestControl> for Decode {
    fn pipe(&mut self, data: &PhaseResult<String>) {
        self.test_id = match data {
            Ok(id) => {
                let new_id = (**id).clone();
                new_id
            },
            Err(_) => String::default(),
        }
    }
    fn run(&mut self) -> PhaseResult<testsystem::TestControl> {
        /* ready check */
        self.test_control.test_id = self.test_id.clone();
        if self.test_id != String::default() {
            testsystem::TestMachine::run(&mut self.test_control);
            if self.test_control.id_match {
                self.test_control.enable = true;
            }
        }

        Ok(IterData::new(self.test_control.clone()))
    }
    fn rst(&mut self) {
        self.control.rst = true;
        self.test_id = String::default();
        self.test_control = testsystem::TestControl::default();
        self.control.rst = false;
    }
    /* default implementations for clk, stall and halt */
}
```

The noise is commented out in this code listing. The input type is `String` with the test-id and the output type is a TestControl structure. The test-id that enters this phase is cloned and saved internally. At next we clone the test-id into the TestControl data structure and check with our TestMachine-implementation if there is a test with the saved test-id. If there is, the test is marked as to be enabled and send into the pipe. 

## Execution

## Write

## Conclusion 
<!-- TODO: write about phase implementations -->


# References
 1. M. Zhu, W. Liu, Z. Fang and W. Hu, "Design of Pipeline Structure to Improve Data Acquisition Rate," 2008 International Workshop on Education Technology and Training & 2008 International Workshop on Geoscience and Remote Sensing, Shanghai, 2008, pp. 783-786, doi: 10.1109/ETTandGRS.2008.318. [https://ieeexplore.ieee.org/document/5070268](https://ieeexplore.ieee.org/document/5070268)
 2. [https://docs.rs/iterpipes/0.2.0/iterpipes/](https://docs.rs/iterpipes/0.2.0/iterpipes/)
